
/* 
    This example show include multiple buffer files
    and custom error message with info about location
    from lexer and parser, handle file in parser . 
*/

/* Compile:
 
    Linux   :   bison -d -y example10.y -o parser.cpp
                reflex --flex --bison-locations --bison-bridge --header-file=lexer.hpp example10.l -o lexer.cpp
                g++ lexer.cpp parser.cpp -o example10 -I ../include/ ../lib/libreflex.a
   
    Windows :   win_bison -d -y example10.y -o parser.cpp
                ..\vs\reflex --flex --bison-locations --bison-bridge --header-file=lexer.hpp example10.l -o lexer.cpp
                cl  /Feexample10.exe parser.cpp lexer.cpp  /I ..\include\ /link ..\vs\reflex.lib
    
*/


%{
#include <string>
#include <stack>
#include <stdio.h>
#include <stdlib.h>

#include "lexer.hpp"  /* Generated by reflex: scanner_t, yyscan_t, yylex_init, yylex_destroy */

extern int  yylex   (YYSTYPE*           , YYLTYPE*  , yyscan_t      );
void        yyerror (YYLTYPE*           , yyscan_t  , const char*   );
void        yyerror (yyscan_t scanner   , const char *msg           );

/* Pass the parameter 'scanner' to yyparse through to yylex. */
#define YYPARSE_PARAM scanner
#define YYLEX_PARAM   scanner

std::stack<yyscanner_t*> buffer ;
std::stack<const char*>  bufferFileName ;

%}

%locations
%pure-parser
%lex-param { void *scanner }
%parse-param { void *scanner }



%union {
    int   num;
    char *str;
    void* obj ;     // generic object from cpp 
}

%token <str> STRING
%token <num> NUMBER
%token INCLUDE
%token FINE
%token ERROR

%%

assignments : assignment
            | assignment assignments
            ;
assignment
: 
    STRING '=' NUMBER ';' 
    { 
        printf  ("(setf %s %d)\n", $1, $3);
    }
|
    INCLUDE    
    {
        buffer.push ( static_cast<yyscanner_t*>(scanner) ) ;
        static_cast<yyscanner_t*>(scanner)->matcher().flush();
        
        yyscanner_t scannerInclude;
        
        FILE* fi=fopen( "example10b.test", "r" );
        bufferFileName.push ("example10b.test")  ;
        
        scannerInclude.in(fi);

        buffer.push ( &scannerInclude ) ; 
        yyparse ( &scannerInclude ) ;
        
    }
|
    ERROR
    {
        yyerror ( (void*)buffer.top(),"error parser" ) ;
    }        
;

%%

int main(void)
{
    // new way in C++ using reflex-generated yyscanner_t
    yyscanner_t scanner;
    
    // fopen file 
    FILE* fi = fopen ( "example10a.test" , "r" ) ;
    bufferFileName.push ("example10a.test")  ;
    scanner.in(fi)  ;

    // push
    buffer.push ( &scanner ) ;
    bufferFileName.push ("example10a.test")  ;

    // scanner is passed on to yylex()
    yyparse(&scanner);	

    printf ( "\n" );
  
  return 0;
}
void yyerror(YYLTYPE *yylloc, yyscan_t scanner, const char *msg)
{
  (void)scanner; // appease -Wall -Werror
  fprintf(stderr, "%s at %d,%d\n", msg, yylloc->first_line, yylloc->first_column);
}
void yyerror(yyscan_t scanner, const char *msg)
{
    (void)scanner; // appease -Wall -Werror
    int row = static_cast<yyscanner_t*>(scanner)->matcher().lineno() ;
    int col = static_cast<yyscanner_t*>(scanner)->matcher().columno() + 1 ; 
    fprintf(stderr, "FILE : %s error : %s at %d,%d\n", bufferFileName.top(),msg, row,col  );
    //exit(-1);
}

